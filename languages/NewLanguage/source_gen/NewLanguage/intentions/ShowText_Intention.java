package NewLanguage.intentions;

/*Generated by MPS */

import jetbrains.mps.intentions.IntentionDescriptorBase;
import jetbrains.mps.intentions.IntentionFactory;
import java.util.Collection;
import jetbrains.mps.intentions.IntentionExecutable;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import jetbrains.mps.intentions.IntentionType;
import jetbrains.mps.smodel.SNodePointer;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.openapi.editor.EditorContext;
import java.util.Collections;
import jetbrains.mps.intentions.IntentionExecutableBase;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import org.apache.log4j.Level;
import jetbrains.mps.text.TextGeneratorEngine;
import jetbrains.mps.intentions.IntentionDescriptor;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public final class ShowText_Intention extends IntentionDescriptorBase implements IntentionFactory {
  private Collection<IntentionExecutable> myCachedExecutable;
  public ShowText_Intention() {
    super(MetaAdapterFactory.getConcept(0xd2af129e2d34893L, 0xa2116092c06be5a5L, 0x30afa9ce0328feb4L, "NewLanguage.structure.Base"), IntentionType.NORMAL, false, new SNodePointer("r:6eb74a24-1db7-4ce5-880c-95309b478310(NewLanguage.intentions)", "3508209337026353140"));
  }
  @Override
  public String getPresentation() {
    return "ShowText";
  }
  @Override
  public boolean isApplicable(final SNode node, final EditorContext editorContext) {
    return true;
  }
  @Override
  public boolean isSurroundWith() {
    return false;
  }
  public Collection<IntentionExecutable> instances(final SNode node, final EditorContext context) {
    if (myCachedExecutable == null) {
      myCachedExecutable = Collections.<IntentionExecutable>singletonList(new ShowText_Intention.IntentionImplementation());
    }
    return myCachedExecutable;
  }
  /*package*/ final class IntentionImplementation extends IntentionExecutableBase {
    public IntentionImplementation() {
    }
    @Override
    public String getDescription(final SNode node, final EditorContext editorContext) {
      return "Show Generated Text in Messages";
    }
    @Override
    public void execute(final SNode node, final EditorContext editorContext) {
      // Given the openapi.model.SNode parameter, we need to find the correct jetbrains.mps.smodel.SNode 
      SModel model = SNodeOperations.getModel(node);
      List<jetbrains.mps.smodel.SNode> rootNodes = ListSequence.fromList(new ArrayList<jetbrains.mps.smodel.SNode>());
      for (SNode rootNode : Sequence.fromIterable(model.getRootNodes())) {
        ListSequence.fromList(rootNodes).addElement(((jetbrains.mps.smodel.SNode) rootNode));
      }
      jetbrains.mps.smodel.SNode snode = ListSequence.fromList(rootNodes).getElement(ListSequence.fromList(SModelOperations.roots(SNodeOperations.getModel(node), null)).indexOf(node));

      if (snode == null) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("Node not found");
        }
      }

      // Node must have a name, e.g., implement INamedConcept 
      if (snode.getName() == null) {
        if (LOG.isEnabledFor(Level.ERROR)) {
          LOG.error("node must have a name");
        }
      }

      String text = TextGeneratorEngine.generateText(snode);

      // Print each line to the Messages window 
      for (String line : text.split("\\r?\\n")) {
        if (LOG.isInfoEnabled()) {
          LOG.info("line " + line);
        }
      }



    }
    @Override
    public IntentionDescriptor getDescriptor() {
      return ShowText_Intention.this;
    }
  }
  protected static Logger LOG = LogManager.getLogger(ShowText_Intention.class);
}
